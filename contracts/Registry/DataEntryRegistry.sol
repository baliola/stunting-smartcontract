// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IRBAC} from "../Interface/IRBAC.sol";
import {IDataEntry} from "../Interface/IDataEntry.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/// @title DataRegistry
/// @author @anggadanarp
/// @notice Abstract contract to handle metadata hash submission by authorized users (e.g., Posyandu/Puskesmas).
/// @dev Inherits from RBACRegistry and verifies role access, uniqueness of data, and ECDSA signatures.
abstract contract DataEntryRegistry is IDataEntry {
    using ECDSA for bytes32;
    IRBAC public rbac;

    // ================================================================================
    //                                     CONSTANTS
    // ================================================================================
    /// @notice Role identifier for users allowed to submit data (e.g., Posyandu/Puskesmas).
    bytes32 public constant DATA_ENTRY_ROLE = keccak256("DATA_ENTRY_ROLE");

    // ================================================================================
    //                                MAPPING
    // ================================================================================
    /// @dev Mapping from metadata hash to submitted data.
    mapping(bytes32 => DataEntry) private _submittedData;

    /// @dev Tracks whether a hash has been previously submitted to prevent duplicates.
    mapping(bytes32 => bool) private _isSubmitted;

    constructor(address rbacRegistry) {
        rbac = IRBAC(rbacRegistry);
    }

    // ================================================================================
    //                              INTERNAL FUNCTION
    // ================================================================================
    /// @notice Submit a metadata hash signed by a valid data entry user.
    /// @dev Will revert if the dataHash is duplicate, if the signer is unauthorized, or if signature is invalid.
    /// @param metadataHash The keccak256 hash of the structured off-chain metadata payload.
    /// @param signature The ECDSA signature generated by the submitter over the metadataHash.
    function _submitData(
        bytes32 metadataHash,
        bytes calldata signature
    ) internal {
        if (_isSubmitted[metadataHash]) revert DuplicateData(metadataHash);

        address signer = _recoverSigner(metadataHash, signature);

        if (!rbac.checkAccessLog(signer, DATA_ENTRY_ROLE)) revert DataEntryUnauthorized(signer);
        if (signer != msg.sender) revert DataEntryInvalidSignature(signer, msg.sender);

        _submittedData[metadataHash] = DataEntry({
            submitter: signer,
            timestamp: block.timestamp,
            signature: signature
        });

        _isSubmitted[metadataHash] = true;

        emit DataSubmitted(metadataHash, signer, block.timestamp);
    }

    // ================================================================================
    //                             PRIVATE HELPER
    // ================================================================================
    /// @notice Recovers the signer address from the signed metadata hash.
    /// @param hash The original keccak256 metadata hash that was signed.
    /// @param signature The ECDSA signature provided by the user.
    /// @return signer The address that signed the hash.
    function _recoverSigner(
        bytes32 hash,
        bytes memory signature
    ) private pure returns (address signer) {
        return MessageHashUtils.toEthSignedMessageHash(hash).recover(signature);
    }

    // ================================================================================
    //                             INTERNAL GETTERS
    // ================================================================================
    /// @notice Retrieves the stored DataEntry struct for a given metadata hash.
    /// @param dataHash The keccak256 hash of the metadata.
    /// @return entry The data entry containing signer, timestamp, and signature.
    function _getDataEntry(
        bytes32 dataHash
    ) internal view returns (DataEntry memory entry) {
        return _submittedData[dataHash];
    }

    /// @notice Checks whether a given metadata hash has already been submitted.
    /// @param hash The metadata hash to check.
    /// @return submitted True if the hash has been submitted, false otherwise.
    function _isDataSubmitted(
        bytes32 hash
    ) internal view returns (bool submitted) {
        return _isSubmitted[hash];
    }
}
